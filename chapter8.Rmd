---
title       : Estimation
description : UNDER CONSTRUCTION



--- type:NormalExercise lang:r xp:100 skills:1 key:23abc9f934

## Indices and brackets

Vectors store multiple values of the same data type. The values in vectors have indices: the first value in a vector has a index `1`, the second value has `2` and so on. 

You can set or get a single value from a vector by using indices and brackets `[ ]`. Using an index number inside the bracets gives access to a single value from the vector. Using a vector of indices gives access to a vector of values.

It is also possible to rearrange the values in a vector by using indices. Look at the example code to see how indices work. 

*** =instructions
- Create the name vector.
- See how the indices work by executing the example lines.
- Use brackets and indices on `names` to create a new vector `girls` with values "Liisa" and "Anna" (in that order).
- Use brackets and indices on `names` to create a new vector `boys` with values "Pekka" and "Heikki" (in that order)

*** =hint
- Note that space between the vector object and bracets produces an error.
- Remember that vectors are created with the function `c()`.
- Index vectors `c(1,2)` and `c(2,1)` do not produce the same outcome. The order of the values is different.

*** =pre_exercise_code
```{r}
```


*** =sample_code
```{r}
# Let's create a vector
names <- c("Matti", "Pekka", "Liisa", "Anna")

# Acess the first value of the vector
names[1]

# Change the first value of the vector
names[1] <- "Heikki"

# Acess the 1. and 3. value of the vector
names[c(1, 3)]

# Use indices and brackets to separate the names vector into two vectors of the specified ordering
girls <-
boys <-

```

*** =solution
```{r}
# Let's create a vector
names <- c("Matti", "Pekka", "Liisa", "Anna")

# Acess the first value of the vector
names[1]

# Change the first value of the vector
names[1] <- "Heikki"

# Acess the 1. and 3. value of the vector
names[c(1, 3)]

# Use indices and brackets to separate the names vector into two vectors of the specified ordering
girls <- names[c(3, 4)]
boys <- names[c(2, 1)]

```

*** =sct
```{r}

test_object("girls", incorrect_msg = "Did you create `girls`?")
test_object("boys", incorrect_msg = "Did you create `boys`? Are the values in the correct order?")

test_error()

# Final message the student will see upon completing the exercise
success_msg("Such indices. Wow. Much intelligent.")

```


--- type:NormalExercise lang:r xp:100 skills:1 key:8e0ac16859

## Easy vectors

Sometimes you need a very long index vector. In that case it would be a lot of work to create the vector by combining integer values with `c()`. Luckily, there are convenient ways to create long vectors in R.

For index values, a specially useful one is the method `start:end`, which creates an integer vector with all the values between start and end (inclusive). The following two lines hence produce identical results

```
1:5  
c(1,2,3,4,5)
```


*** =instructions
- Study and execute the example codes
- Print out every second value of the attitude vector, starting from the 2. value until the 20th value. These values correspond to the even numbered indeces of the vector: 2, 4, .. , 20

*** =hint
- First you will need an index vector with values 2, 4, .. , 20. The example shows how to create such a vector
- You can then use the index vector together with brackets (`[ ]`) to complete the task


*** =pre_exercise_code
```{r}
learning2014 <- read.table("http://www.helsinki.fi/~kvehkala/JYTmooc/learning2014.txt", sep = "\t", header = TRUE)
attitude <- learning2014$attitude
names(attitude) <- 1:length(attitude)
```

*** =sample_code
```{r}
# attitude is available

# Create an integer vector
1:5

# Create an integer vector with even values 2, 4, .. , 10
(1:5)*2

# Access the values 5 - 10 of attitude
attitude[5:10]

# Access every second value of attitude from 2. to the 20th index


```

*** =solution
```{r}
# attitude is available

# Create an integer vector
1:5

# Create an integer vector with even values
(1:5)*2

# Access the values 5 - 10 of attitude
attitude[5:10]

# Access every second value of attitude from 2. to the 20th index
attitude[(1:10)*2]


```

*** =sct
```{r}
# submission correctness tests

test_output_contains("attitude[(1:10)*2]")

# test if the students code produces an error
test_error()

# Final message the student will see upon completing the exercise
success_msg("Great work!")

```

--- type:NormalExercise lang:r xp:100 skills:1  key:78e301b70a

## Point estimation

Let us now get back to statistical analysis and estimation. When given a sample of data from a population, the goal of statistical analysis is to use that sample to draw conclusions about the population. In a simple case we are interested of a single variable (such as students points in an exam) and want to estimate the *expected value* of that variable. The expected value is the average value in the population - the population mean. 

We can't directly calculate the population average because we only have a sample, so we have to **estimate** it. Obtaining a point estimate of a population parameter is easy: just use the corresponding sample statistic.

population parameter                    | estimate
--------------------------------------- | --------
expected value $\mu$                    | sample mean $\bar{x}$
population standard deviation $\sigma$  | sample standard deviation $s$


*** =instructions
- Estimate the expected value of `points`
- Estimate the population standard deviation of `points`
- Print out the estimated values
- Remember that R has convenient functions for these kind of calculations. If you can't remember them, you can for example use you favourite search engine and type "compute <operation here> in r" or take a hint.

*** =hint
- The table above shows the relationships between the sample statistics and the population parameters
- Mean can be computed with `mean()`



*** =pre_exercise_code
```{r}
learning2014 <-  read.table("http://www.helsinki.fi/~kvehkala/JYTmooc/learning2014.txt", sep = "\t", header = TRUE)
```

*** =sample_code
```{r}
# learning2014 is available

# create object points using the learning2014 data.frame
points <- learning2014$points

# estimate the expected value of points
mu <- 

# estimate the population standard deviation of points
s <- sd(points)

# Print out the estimated values




```

*** =solution
```{r}
# learning2014 is available

# create object points using the learning2014 data.frame
points <- learning2014$points

# estimate the expected value of points
mu <- mean(points)

# estimate the population standard deviation of points
s <- sd(points)

# Print out the estimated values
mu
s


```

*** =sct
```{r}
# submission correctness tests

test_function("mean", args=c("x"))
test_object("mu")

test_output_contains("mu")
test_output_contains("sigma")

# test if the students code produces an error
test_error()

# Final message the student will see upon completing the exercise
success_msg("Great work!")

```


--- type:NormalExercise lang:r xp:100 skills:1 key:1df061a41a

## Interval estimation

Since we are using a sample, clearly there is some uncertainty involved in our point  estimate. But how much uncertainty?

This is where we need statistical theory. It turns out that the following formula produces an interval around the estimate which contains the true parameter value a specified high percentage of the time ($100 \cdot (1-\alpha)$%) 

$$\text{estimate] +- z(\alpha/2) \cdot \frac{s}{\sqrt{n}}$$

Here $s$ is the sample standard deviation, $n$ is the sample size and $z(\frac{\alpha}{2})$ is a critical value from the $N(0,1)$ distribution. $\frac{s}{\sqrt{n}$ is called the *standard error* of the estimate. 

I know what you're thinking. It's confusing: where did the normal distribution come from and what's with all that $z(\frac{\alpha}{2})$ stuff? The answers lie in the **sampling distribution** which we will soon get to.


*** =instructions
- Compute the estimate for the expected value of points, the sample standard deviation and the number of observations
- Compute the standard error of the estimate (the sample mean)
- Compute the critical value z using a 99% confidence level (alpha = 0.01)
- Print out the confidence interval CI

*** =hint
- The formula for the standard error is s/sqrt(n)
- The function qnorm() computes quantile values from the N(0,1) distribution. Use it as instructed in the code comments.


*** =pre_exercise_code
```{r}
learning2014 <-  read.table("http://www.helsinki.fi/~kvehkala/JYTmooc/learning2014.txt", sep = "\t", header = TRUE)

points <- learning2014$points

```

*** =sample_code
```{r}
# points is available.

# Number of observations
n <- length(points)

# Estimate the expected value and standard deviation of points
mu <- mean(points)
s <- sd(points)

# Compute the standard error of mu. sqrt() computes the square root.
error <- 
  
# Use qnorm(1 - alpha/2) to compute the critical value z
z <- 

# Compute the confidence interval
lower_ci <- mu - z*error
upper_ci <- mu + z*error

# Print out the results in a (rounded and named) vector
CI <- round(c("estimate" = mu, "lower99%" = lower_ci, "upper99%" = upper_ci),1)


```

*** =solution
```{r}
# points is available

# number of observations
n <- length(points)

# estimate the expected value and standard deviation of points
mu <- mean(points)
s <- sd(points)

# estimate the standard error of mu
error <- s/sqrt(n)
  
# Use qnorm(1 - alpha/2) to get the value of z with the specified confidence level
z <- qnorm(1 - 0.01/2)

# compute the confidence interval and print out the results
lower_ci <- mu - z*error
upper_ci <- mu + z*error

CI <- round(c("estimate" = mu, "lower_ci" = lower_ci, "upper_ci" = upper_ci),1)


```

*** =sct
```{r}
# submission correctness tests
test_object("error")
test_object("z")
test_object("lower_ci")
test_object("upper_ci")
test_output_contains("CI")

# test if the students code produces an error
test_error()

# Final message the student will see upon completing the exercise
success_msg("You are awsome with 99% confidence!")


```


--- type:NormalExercise lang:r xp:100 skills:1 key:a26cc4ab51

## Looping

In programming, often times there is the need to repeat an action multiple times. In statistical programming you might for example have a theory you wish to explore by simulation.

The **for-loop** is perhaps the most common loop. The structure of a for-loop is:

```
for (counter in vector) {
  commands
}
```

The for-loop iterates trough the values of a vector by changing the value of the counter one value at a time. Inside the curly braces are regular commands such as function calls and the current value of the counter can be used there.

The commands are repeated until all the values of the vector have been looped through.


*** =instructions
- Execute the example codes. Remember that here in DataCamp, executing a command over multiple lines is done by selecting all the lines with a mouse first (by painting) and then hitting Ctrl+Enter normally. Alternatively you can  also click submit.
- Create your own for-loop which prints out "I am looping" 50 times.
- Hints: Remember that `1:n` creates an integer vector of length n. Inside the loop body (curly braces) you have to use the `print()` function to print.

*** =hint
- It does not matter what name you give to your counter. You can for example use `i` as is done in the second example. You don't need to access your counter in this exercise.
- Remember to use quotation marks to create characters


*** =pre_exercise_code
```{r}
# no pec
```

*** =sample_code
```{r}
# loop through characters a,b,c,d
for(letter in c("a","b","c")) {
  print(letter)
}

# loop through integers 1,2,3,4,5
for(i in 1:5) {
  print(i + 5)
}

# write a for-loop that prints out "I am looping" 50 times





```

*** =solution
```{r}
# loop through characters a,b,c,d
for(letter in c("a","b","c")) {
  print(letter)
}

# loop through integers 1,2,3,4,5
for(i in 1:5) {
  print(i + 5)
}

# write a for-loop that prints out "I am looping" 50 times
for(i in 1:50) {
  print("I am looping")
}


```

*** =sct
```{r}
# submission correctness tests

test_output_contains("'I am looping'", times = 50, incorrect_msg = "Did you write a for-loop that prints out 'I'm looping' 50 times?")

# test if the students code produces an error
test_error()

# Final message the student will see upon completing the exercise
success_msg("Excellent work! Repetition is the key to success :)")

```



--- type:NormalExercise lang:r xp:100 skills:1 key:65d85c42aa

## The sampling distribution


Usually, whenever you have a set of data, that data is only a sample from a target population. Therefore all the statistics calculated from the data involve uncertainty. But how much uncertainty? Do we know the distribution of the statistic?

What if we could also estimate how a statistic is distributed between different kinds of samples? What if we knew the **sampling distribution** of the statistic that produced our estimate. Well, lets start by simulating that distribution.

Let's pretend for a moment that the data that we have actually *is* the target population we are sampling from. Let's see what happens if we repeatedly take samples from that population, and calculate a statistic each time, storing the results.


*** =instructions
- Create an empty means vector and print it
- Execute the for-loop to fill the means vector with means from random samples of points.
- Use `summary()` on means
- Draw a histogram of the means
- Use `quantile()` with means as the first argument. define the argument `probs = c(0.01, 0.99)/2`. The output is the range that contains 99% of the values.


*** =hint
- `hist()` draws a histogram


*** =pre_exercise_code
```{r}
learning2014 <-  read.table("http://www.helsinki.fi/~kvehkala/JYTmooc/learning2014.txt", sep = "\t", header = TRUE)
points <- learning2014$points

```

*** =sample_code
```{r}
# points is available

# Create an empty vector of lenght N
N <- 100
means <- numeric(N)
means

# repeat N times: draw a random sample and compute the mean
for(i in 1:N) {
  points_sample <- sample(points, size = 50, replace = F)
  means[i] <- mean(points_sample)
 }
 
# Explore the sampling distribution




```

*** =solution
```{r}
# points is available

# Create an empty vector of lenght N
N <- 100
means <- numeric(N)
means

# Repeat N times: (1) draw a random sample (2) compute and save the mean
for(i in 1:N) {
  points_sample <- sample(points, size = 50, replace = F)
  means[i] <- mean(points_sample)
 }
 
# Explore the sampling distribution
summary(means)
hist(means)
quantile(mean, probs = c(0.01, 0.99)/2)

```

*** =sct
```{r}
# submission correctness tests

test_function("summary", args=c("arg1"))
test_function("hist", args=c("arg1"))
test_function("quantile",args=c("x", "probs"))

# test if the students code produces an error
test_error()

# Final message the student will see upon completing the exercise
success_msg("Good work!")

```


--- type:NormalExercise lang:r xp:100 skills:1 key:38bf66cd9c

## The central limit theorem

Yleistetään edellisen tehtävän huomio

*** =instructions
- instruction 1
- instruction 2

*** =hint
- hint 1
- hint 2


*** =pre_exercise_code
```{r}
# pre exercise code here
```

*** =sample_code
```{r}
# df is available

#explore means
summary(means)
hist(means)

```

*** =solution
```{r}
#solution code here
```

*** =sct
```{r}
# submission correctness tests

# example tests:
# test_output_contains("output")
# test_object("object_name")
# test_function("function_name", args=c("arg1"))

# test if the students code produces an error
test_error()

# Final message the student will see upon completing the exercise
success_msg("Good work!")

```
